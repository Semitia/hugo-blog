[{"content":"","date":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog"},{"content":" Hugo #环境配置 #使用docker开发\ndocker pull hugomods/hugo:ci 创建Hugo网页项目 #如果已有Hugo项目可跳过\nmkdir Hugo cd Hugo docker run --rm -it \\ -v $(pwd):/src \\ hugomods/hugo:ci new site . 拉取主题\nsudo git -c http.proxy=http://127.0.0.1:7890 submodule add -b stable https://github.com/jpanther/congo.git themes/congo 根据主题配置文档更换网页项目内容\nhttps://jpanther.github.io/congo/docs/installation/#create-a-new-site\n也可以继续参考文档个性化定制\nhttps://jpanther.github.io/congo/zh-hans/docs/getting-started/\n容器开发 #docker compose 文件\nservices: myHugo: image: hugomods/hugo:reg-exts container_name: Hugo-container network_mode: host environment: - HTTP_PROXY=http://127.0.0.1:7890 - HTTPS_PROXY=http://127.0.0.1:7890 volumes: - ~/Blogs/Hugo:/src privileged: true working_dir: /src stdin_open: true tty: true command: server -D -p 1313 --bind 0.0.0.0 启动容器\ndocker compose up -d 此时，没有报错的情况下可以通过浏览器访问 http://localhost:1313/查看效果\n常用操作 #vercel #建立vercel项目 #在Hugo仓库添加vercel的配置文件\n将Hugo仓库上传到github，之后在Vercel上绑定github账号\n在vercel新建项目(new project)，选择Hugo仓库\nFramework Preset 可以直接选择Hugo\nRoot Directory 不用修改 ![[IMG-20250114162457070.png]]\n绑定域名 #在Hugo项目管理中点击Domain，添加域名。 按照vercel给出的配置，在域名提供商那里修改域名DNS配置即可。\n![[IMG-20250114162457092.png]] ![[IMG-20250114162457143.png]]\n自动部署脚本 #目前使用自动脚本将obsidian特定文件夹下的笔记修改同步到hugo目录，不过如果想给类似post的目录添加_index.md页面，需要将笔记平铺在其同级，如\n|-content | |-post | |-_index.md | |-note_dir | | |-index.md | | |-thumb.jpg 同时发现这样才能正常显示文章summary\n","date":"2025年1月21日","permalink":"/posts/blogs/","section":"开发随笔","summary":"Blog configuration with common frameworks.","title":"Blogs"},{"content":"","date":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker"},{"content":" 安装与配置 # 1. 安装 Docker #步骤 1：更新系统包 #确保系统的包是最新的：\nsudo apt update sudo apt upgrade -y 步骤 2：安装 Docker #运行以下命令以安装 Docker：\nsudo apt install docker.io -y 步骤 3（可选）：启动和设置 Docker 服务 #启动 Docker 并将其设置为开机自启动：\nsudo systemctl start docker sudo systemctl enable docker 步骤 4：验证 Docker 是否安装成功 #运行以下命令检查 Docker 版本：\ndocker --version 输出类似于 Docker version xx.xx.xx 表示安装成功。\n配置 Docker 使用代理 #创建配置文件并添加代理设置：\n创建或编辑 Docker 服务的配置文件：\nsudo mkdir -p /etc/systemd/system/docker.service.d sudo gedit /etc/systemd/system/docker.service.d/http-proxy.conf 在 http-proxy.conf 文件中添加以下内容：\n[Service] Environment=\u0026#34;HTTP_PROXY=http://127.0.0.1:7890/\u0026#34; Environment=\u0026#34;HTTPS_PROXY=http://127.0.0.1:7890/\u0026#34; Environment=\u0026#34;NO_PROXY=localhost,127.0.0.1\u0026#34; 重新加载系统守护进程配置并重启 Docker 服务：\nsudo systemctl daemon-reload sudo systemctl restart docker 添加用户组 #避免每次使用docker都需要sudo\nPost-installation steps | Docker Docs\n用户名似乎需要小写\nalexavier@alexavier:~$ sudo usermod -aG docker Alexavier usermod：用户“Alexavier”不存在 alexavier@alexavier:~$ sudo usermod -aG docker alexavier 配置完似乎还需要重启/重新登录一下vscode插件才能用\n常用操作 #拉取镜像 #docker pull osrf/ros:noetic-desktop-full 查看本地镜像 #docker images 查看运行中的容器 #docker ps 查看所有容器（包括已停止的容器） #docker ps -a 启动容器 #如果多个容器共用同一个镜像，镜像的只读部分会被共享，不会重复占用空间。\ndocker run -it my_noetic:7_26 /bin/bash docker run -it --network host my_noetic:7_26 /bin/bash docker run -it --network host -v ~/SumResearch_2024/Repo/Host/ROS1_ws:/root/ROS1_ws my_noetic:latest /bin/bash docker run -it --network host -v ~/SumResearch_2024/Repo/Host/ROS1_ws:/root/ROS1_ws -v ~/SumResearch_2024/Repo/RDKx5:/root/RDKx5 arm_noetic:latest docker run -it --network host -v ~/SumResearch_2024/Repo/Host/ROS1_ws:/root/ROS1_ws -v ~/SumResearch_2024/Repo/RDKx5:/root/RDKx5 --privileged --device /dev/ttyUSB0 arm_noetic:latest 启动新的shell会话 #找到运行中的容器ID或者容器名，假如为my_noetic_container\ndocker exec -it my_noetic_container /bin/bash 关闭容器 #docker kill \u0026lt;container_name_or_id\u0026gt; 保存容器为镜像 #docker commit youthful_khayyam airbot_img:latest 查看容器的空间占用 #docker system df 本地保存和加载 Docker 镜像 #将 Docker 镜像保存为一个文件，然后在其他地方加载这个文件。\n保存镜像 #使用 docker save 命令将镜像保存为 tar 文件：\ndocker save -o my-ubuntu-image.tar my-ubuntu-image 加载镜像 #docker load -i my-ubuntu-image.tar 删除镜像和容器 # 删除容器：\ndocker rm \u0026lt;container_id_or_name\u0026gt; 删除镜像：\ndocker rmi \u0026lt;image_id_or_repository:tag\u0026gt; 文件操作 #复制到容器 #docker cp ~/SumResearch_2024/Repo/Host/ROS1_ws youthful_khayyam:/home/ GUI配置 #主机 #安装x11\nsudo apt update sudo apt install xserver-xorg xauth 验证功能\nxeyes 授予权限\nxhost +local: 容器 #建议使用compose打开容器，具体内容可参考后面的\n安装x11\napt update apt install -y x11-apps 测试\nxeyes Dockerfile #文件示例 #Dockerfile 是一个文本文件，包含了一系列指令，用于定义如何构建 Docker 镜像。假设你想要创建一个包含基本 Ubuntu 系统的 Docker 镜像，可以创建一个简单的 Dockerfile：\n# 使用官方的 Ubuntu 镜像作为基础镜像 FROM ubuntu:20.04 # 维护者信息 LABEL maintainer=\u0026#34;your_email@example.com\u0026#34; # 更新包列表并安装一些基础工具 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ curl \\ wget \\ vim \\ git \\ \u0026amp;\u0026amp; apt-get clean # 设置工作目录 WORKDIR /root # 复制你的系统配置文件（可选） # COPY my_config_file /root/my_config_file # 安装其他软件或进行其他配置（根据需要） # RUN ... # 默认命令 CMD [\u0026#34;bash\u0026#34;] 你可以根据自己的需求在 Dockerfile 中添加更多指令，例如安装其他软件、复制文件等。\n使用 Docker 构建镜像 #在 Dockerfile 所在的目录，打开终端并运行以下命令构建 Docker 镜像：\ndocker build -t my-ubuntu-image . 其中 my-ubuntu-image 是你给镜像指定的名字，. 表示 Dockerfile 在当前目录。\nDocker Compose #Docker Compose 使用一个 YAML 文件来定义和管理多个容器，从而简化命令行操作。\n安装 #Docker Compose 的官方文档\nDocker Compose | 菜鸟教程\n使用方法 #在项目根目录下创建一个 docker-compose.yml 文件，并在其中添加以下内容：\nversion: \u0026#39;3.8\u0026#39; services: arm_noetic: image: arm_noetic:latest container_name: arm_noetic_container network_mode: host volumes: - ~/SumResearch_2024/Repo/Host/ROS1_ws:/root/ROS1_ws - ~/SumResearch_2024/Repo/RDKx5:/root/RDKx5 privileged: true devices: - \u0026#34;/dev/ttyUSB0:/dev/ttyUSB0\u0026#34; stdin_open: true tty: true 在这个文件中：\nversion 指定了 Docker Compose 文件的版本。 services 部分定义了一个服务（即容器），这里命名为 arm_noetic。 image 指定了要使用的 Docker 镜像。 container_name 为容器指定了一个名字。 network_mode 设置为 host，与 --network host 参数相同。 volumes 定义了需要挂载的卷。 privileged 设置为 true，使容器具有特权。 devices 部分指定了需要共享的设备。 stdin_open 和 tty 设置为 true，以启用交互模式。 使用以下命令以后台模式启动容器：\ndocker-compose up -d 注意，这个方法会删除已有的同名容器，并用镜像重新创建容器。如果只是启动已经存在但处于停止状态的容器，使用以下命令：\ndocker compose start docker compose plugin #在使用24.04的时候，docker-compose 用不了，因为 docker-compose 1.x 版本依赖 distutils，而 distutils 在Python 3.12 中被移除。新版 docker-compose 已转为使用 Go 实现 (docker-compose-plugin)，不再依赖 Python。 安装方法\nsudo apt remove docker-compose # 添加docker官方源 sudo apt update sudo apt install -y ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt update # 安装 \u0026amp; 验证 sudo apt install docker-compose-plugin docker compose version 相应的，compose配置似乎也要稍微修改\nversion: \u0026#39;3.8\u0026#39; services: graspnet: image: nvidia/cuda:12.1.0-devel-ubuntu22.04 # 使用你下载的镜像 container_name: graspnet-container network_mode: host environment: - NVIDIA_VISIBLE_DEVICES=all # 显示所有 GPU（可指定 GPU） - NVIDIA_DRIVER_CAPABILITIES=all - DISPLAY=${DISPLAY} # 支持可视化 - QT_X11_NO_MITSHM=1 # 防止 Qt 报错 - HTTP_PROXY=http://127.0.0.1:7890 # Clash 代理端口 - HTTPS_PROXY=http://127.0.0.1:7890 volumes: - ~/graspnet:/workspace # 挂载本地 ~/graspnet 到容器内 /workspace - /media/user/disk/dataset/graspnet:/workspace/dataset - /tmp/.X11-unix:/tmp/.X11-unix # 共享 X11 的 Unix socket，支持 GUI privileged: true working_dir: /workspace # 容器内的默认工作目录 stdin_open: true # 支持交互式会话 tty: true # 启用终端 deploy: resources: reservations: devices: - capabilities: [gpu] 容器内使用显卡 #为了支持 GPU，需要安装 NVIDIA Container Toolkit。\n设置 NVIDIA Docker 存储库 #添加 NVIDIA 的 GPG 密钥和存储库：\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\ \u0026amp;\u0026amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \\ \u0026amp;\u0026amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list 安装 NVIDIA Container Toolkit #更新包列表并安装：\nsudo apt update sudo apt install -y nvidia-docker2 # 下载太慢也可以走代理 sudo apt -o Acquire::http::Proxy=\u0026#34;http://127.0.0.1:7890\u0026#34; \\ -o Acquire::https::Proxy=\u0026#34;http://127.0.0.1:7890\u0026#34; install -y nvidia-docker2 重启 Docker 服务 #sudo systemctl restart docker 验证 NVIDIA Docker 是否可用 #运行以下命令检查 GPU 是否可以被 Docker 访问：\ndocker run --rm --gpus all nvidia/cuda:11.8-base nvidia-smi # 监控GPU使用情况 sudo apt install gpustat gpustat --watch 如果显示GPU 信息，说明安装成功。\nUbuntu 24.04版本 #目前（2024.12.15）NVIDIA Container Toolkit 还不支持 ubuntu 24.04,不过也能下载，参考:\nhttps://www.server-world.info/en/note?os=Ubuntu_24.04\u0026p=nvidia\u0026f=3\n总结一下\n# 更新依赖和系统 sudo apt update sudo apt install -y curl apt-transport-https ca-certificates software-properties-common # 添加 NVIDIA GPG 公钥 curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-toolkit.gpg # 添加 NVIDIA 容器工具包源 curl -fsSL https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \\ sudo tee /etc/apt/sources.list.d/nvidia-toolkit.list sudo sed -i -e \u0026#34;s/^deb/deb [signed-by=\\/usr\\/share\\/keyrings\\/nvidia-toolkit.gpg]/g\u0026#34; /etc/apt/sources.list.d/nvidia-toolkit.list # 更新包索引和安装工具包 sudo apt update sudo apt install -y nvidia-container-toolkit # 重启 Docker 并测试 sudo systemctl restart docker sudo docker run --rm --gpus all nvidia/cuda:12.3.0-runtime-ubuntu22.04 nvidia-smi 拉取 CUDA 11.8 镜像 #https://hub.docker.com/r/nvidia/cuda/tags\n选择适合的镜像并运行：\nsudo docker pull nvidia/cuda:11.8.0-base-ubuntu22.04 运行容器 #使用 CUDA 镜像启动容器并验证 CUDA 是否可用：\ndocker run --rm --gpus all -it nvidia/cuda:11.8-base-ubuntu22.04 bash 或者用compose\nversion: \u0026#39;3.8\u0026#39; services: graspnet: image: pytorch/pytorch:2.2.0-cuda11.8-cudnn8-devel # 使用你下载的镜像 container_name: graspnet-container network_mode: host runtime: nvidia # 启用 GPU 支持（需安装 NVIDIA Container Toolkit） environment: - NVIDIA_VISIBLE_DEVICES=all # 显示所有 GPU（可指定 GPU） - NVIDIA_DRIVER_CAPABILITIES=all - DISPLAY=${DISPLAY} # 支持可视化 - QT_X11_NO_MITSHM=1 # 防止 Qt 报错 - HTTP_PROXY=http://127.0.0.1:7890 # Clash 代理端口 - HTTPS_PROXY=http://127.0.0.1:7890 volumes: - ~/graspnet:/workspace # 挂载本地 ~/graspnet 到容器内 /workspace - /media/alexavier/8018420DD8B69548/dataset/graspnet:/workspace/dataset - /tmp/.X11-unix:/tmp/.X11-unix # 共享 X11 的 Unix socket，支持 GUI privileged: true working_dir: /workspace # 容器内的默认工作目录 stdin_open: true # 支持交互式会话 tty: true # 启用终端 验证环境： #在容器中运行以下命令：\nnvidia-smi 由于nvcc是devel版本才有的工具，没法用nvcc -V，如果不需要开发cuda程序，只是运行程序时会用到可以只用base\n其他问题 #共享卷导致的git权限问题（可能） #类似这样的\n❯ git pull error: unable to create file RDKx5/hand/servo_limit.json: 权限不够 确保用户拥有整个 Git 仓库的文件和目录的所有权\nsudo chown -R $USER:$USER ~/SumResearch_2024/Repo 容器配置主机代理 #长期配置可在compose添加\nexport HTTP_PROXY=\u0026#34;http://127.0.0.1:7890\u0026#34; export HTTPS_PROXY=\u0026#34;http://127.0.0.1:7890\u0026#34; # test curl -I https://www.google.com Vscode开发 #VSCode Remote - Containers 插件 #修改共享目录权限 # 无法写入文件\u0026quot;/home/semitia/SumResearch_2024/Repo/Host/ROS1_ws/src/hand_control/src/hand_ctrl.py\u0026quot;(NoPermissions (FileSystemError): Error: EACCES: permission denied, open \u0026lsquo;/home/semitia/SumResearch_2024/Repo/Host/ROS1_ws/src/hand_control/src/hand_ctrl.py\u0026rsquo;)\n在宿主机上修改挂载目录的权限，使其对所有用户都可写：\nchmod -R 777 ~/SumResearch_2024/Repo/Host/ROS1_ws ","date":"2025年1月21日","permalink":"/posts/docker-note/","section":"开发随笔","summary":"Practical usage of Docker.","title":"Docker Note"},{"content":"","date":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo"},{"content":"","date":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"终端 #自动补全 #1. Bash Completion #Bash Completion 是一个广泛使用的自动补全脚本，可以为许多常用命令提供自动补全功能。\n安装 Bash Completion： #在 Ubuntu 或 Debian 系统上，可以使用以下命令安装：\nsudo apt update sudo apt install bash-completion 安装完成后，确保在你的 ~/.bashrc 文件中添加以下内容以启用 Bash Completion：\nif ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fi fi 然后，重新加载 ~/.bashrc 文件：\nsource ~/.bashrc 2. fzf #fzf 是一个强大的命令行模糊查找工具，可以与 Bash 和 Zsh 结合使用，提供命令历史记录和文件名的模糊搜索。\n安装 fzf： #在 Ubuntu 或 Debian 系统上，可以使用以下命令安装：\nsudo apt update sudo apt install fzf 安装完成后，你可以将以下内容添加到 ~/.bashrc 文件中以启用 fzf：\n# Use fzf for command history search bind -x \u0026#39;\u0026#34;\\C-r\u0026#34;: \u0026#34;fzf-history\u0026#34;\u0026#39; fzf-history() { local selected=$(HISTTIMEFORMAT= history | fzf +s --tac --reverse --height 40% --border --ansi) READLINE_LINE=\u0026#34;${selected[*]:7}\u0026#34; READLINE_POINT=${#READLINE_LINE} } 然后，重新加载 ~/.bashrc 文件：\nsource ~/.bashrc Zsh #Zsh 安装与配置，使用 Oh-My-Zsh 美化终端 | Leehow的小站\n安装 sudo apt update sudo apt install zsh 切换默认终端到 Zsh chsh -s $(which zsh) 注销并重新登录，使更改生效。\n验证默认终端是否为 Zsh： 重新打开终端，然后输入以下命令来验证当前 shell：\necho $SHELL 输出应该是 /usr/bin/zsh 或类似路径，表示当前默认 shell 已切换到 Zsh。\n配置ROS #将 ROS 2 的路径添加到 PATH 中。\nnano ~/.zshrc\n在文件的末尾添加以下内容\nsource /opt/ros/foxy/setup.zsh\n保存并关闭文件，然后重新加载 `\nsource ~/.zshrc\n验证 ROS 2 命令是否可用\nros2 --help\n配置 Zsh # 安装 Oh My Zsh： sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 安装 zsh-autosuggestions： git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions echo \u0026#34;source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh\u0026#34; \u0026gt;\u0026gt; ~/.zshrc 安装 zsh-syntax-highlighting： git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.zsh/zsh-syntax-highlighting echo \u0026#34;source ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\u0026#34; \u0026gt;\u0026gt; ~/.zshrc 重新加载 .zshrc 文件： source ~/.zshrc 完成这些步骤后，Zsh 将成为你的默认 shell，并且你可以利用其强大的自动补全和提示功能来提高命令行效率。\n在 Zsh 中使用 Oh My Zsh 可以很方便地更换和定制主题。以下是步骤：\n1. 安装 Oh My Zsh #如果你还没有安装 Oh My Zsh，可以使用以下命令进行安装：\nsh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 2. 选择和设置主题 #Oh My Zsh 自带许多主题，你可以在 ~/.zshrc 文件中设置想要使用的主题。以下是几个受欢迎的主题示例：\nagnoster: 一个简洁且信息丰富的主题，适合宽屏显示器。 robbyrussell: Oh My Zsh 默认主题，简洁易用。 powerlevel10k: 一个高度可定制且功能丰富的主题。 修改主题： # 编辑 .zshrc 文件：\nnano ~/.zshrc 找到并修改 ZSH_THEME 行： 将 ZSH_THEME 设置为你想要的主题，例如：\nZSH_THEME=\u0026#34;agnoster\u0026#34; 保存并重新加载 .zshrc 文件：\nsource ~/.zshrc 3. 安装 Powerlevel10k 主题 #如果你想使用 powerlevel10k 主题，以下是安装步骤：\n克隆 Powerlevel10k 仓库： git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 设置 Powerlevel10k 主题： 在 .zshrc 文件中设置主题为 powerlevel10k/powerlevel10k：\nZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; 保存并重新加载 .zshrc 文件：\nsource ~/.zshrc 配置 Powerlevel10k： 重新打开终端，Powerlevel10k 会自动启动配置向导，帮助你定制主题外观。\n4. 安装字体 #为了让一些高级主题（如 powerlevel10k）正常显示，你可能需要安装支持图标和特殊符号的字体，如 MesloLGS NF。\n下载 MesloLGS NF 字体： 从 Nerd Fonts 下载 MesloLGS NF 字体。\n安装字体： 将下载的字体文件安装到系统中。对于 Ubuntu，可以将字体文件复制到 ~/.local/share/fonts 目录，然后运行：\nfc-cache -fv 在终端设置中选择字体： 打开你的终端设置，将字体设置为 MesloLGS NF。\nTilix #在文件夹右键打开终端 # 创建脚本文件： 使用以下命令创建脚本文件：\nmkdir -p ~/.local/share/nautilus/scripts nano ~/.local/share/nautilus/scripts/Open\\ in\\ Tilix 编辑脚本内容： 在打开的文件中输入以下内容：\n#!/bin/bash tilix -w $NAUTILUS_SCRIPT_CURRENT_URI 保存并关闭文件： 在 nano 中，按 Ctrl+O 然后 Enter 保存文件，按 Ctrl+X 退出编辑器。\n设置脚本为可执行： 输入以下命令来设置脚本为可执行：\nchmod +x ~/.local/share/nautilus/scripts/Open\\ in\\ Tilix 完成以上步骤后，你应该能够在文件夹中右键点击，然后选择 “脚本” -\u0026gt; “Open in Tilix” 来在 Tilix 中打开该文件夹了，注意右键文件夹，而不是空白处。\nKitty #Kitty: 又一款基于 GPU 加速的终端工具-CSDN博客\nGitHub - dexpota/kitty-themes: A collection of themes for kitty terminal 😻\nBlog #你已经成功安装了nvm，但需要重新加载shell配置文件以使其生效。你可以按照安装脚本的提示，关闭并重新打开终端，或者手动运行以下命令：\nexport NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion 1. 重新加载配置文件 #你可以手动运行上面的命令或者在终端中输入以下命令来重新加载你的配置文件：\nsource ~/.zshrc 2. 安装Node.js 20版本 #重新加载配置文件后，运行nvm命令来安装Node.js 20：\nnvm install 20 3. 设置默认Node.js版本 #安装完成后，可以设置Node.js 20为默认版本：\nnvm use 20 nvm alias default 20 4. 验证安装 #最后，验证Node.js和npm是否正确安装：\nnode -v npm -v 5. 安装Hexo CLI #现在，你可以安装Hexo CLI：\nnpm install -g hexo-cli 通过这些步骤，你应该能够使用nvm安装并管理Node.js的版本，并成功安装Hexo CLI。如果仍有问题，请随时告知！\n常用应用 #Zotero #以下是安装 Zotero-7.0.11_linux-x86_64.tar.bz2 的步骤：\n似乎有个更简便的\nhttps://github.com/retorquere/zotero-deb\n1. 解压压缩文件 #首先，需要将下载的 tar.bz2 文件解压。\n运行以下命令：\nsudo apt update sudo apt install bzip2 tar -xvjf Zotero-7.0.11_linux-x86_64.tar.bz2 这会将文件解压到当前目录，通常会生成一个名为 Zotero_linux-x86_64 的文件夹。\n2. 移动解压后的文件到系统目录（可选） #为方便管理，可以将解压后的文件夹移动到 /opt 目录下（系统应用通常存放在这里）。\n运行以下命令：\nsudo mv Zotero_linux-x86_64 /opt/zotero 3. 创建桌面快捷方式 #为了方便启动 Zotero，可以创建一个桌面快捷方式。\n编辑快捷方式文件：\nsudo nano /usr/share/applications/zotero.desktop 在文件中添加以下内容：\n[Desktop Entry] Name=Zotero Exec=/opt/zotero/zotero Icon=/opt/zotero/chrome/icons/default/default256.png Type=Application Terminal=false Categories=Office;Education; 保存并退出（按 Ctrl+O 保存，Ctrl+X 退出）。\n4. 为可执行文件创建符号链接 #创建符号链接，以便可以通过命令 zotero 在终端中运行。\n运行以下命令：\nsudo ln -s /opt/zotero/zotero /usr/local/bin/zotero 5. 安装必要的依赖项（如果需要） #Zotero 可能需要一些系统依赖项，确保它们已安装。运行以下命令：\nsudo apt update sudo apt install -y libxss1 libxtst6 libgconf-2-4 libnss3 6. 启动 Zotero #现在，你可以通过以下方式启动 Zotero：\n在终端输入 zotero 并按下回车。 或者通过桌面快捷方式启动。 7. 可选：更新 Zotero #如果需要更新 Zotero，只需重复以上步骤。新的版本可以直接覆盖旧版本文件。\n完成上述步骤后，Zotero 应该可以正常运行！如果你遇到任何问题，请告诉我！\nGNOME #分屏 #1. 安装 GNOME Tweaks 工具 #GNOME Tweaks 用于管理扩展和系统自定义设置：\nsudo apt install gnome-tweaks gnome-shell-extensions 2. 安装 GNOME 扩展浏览器插件 # 打开 GNOME Extensions 官方网站。 安装 GNOME Shell Integration 插件（支持 Firefox 和 Chrome）。 安装完成后，刷新浏览器页面，确保网站可以检测到 GNOME 环境。 推荐的分屏扩展 # Tiling Assistant\n功能： 增强 GNOME 默认的分屏功能。 支持 1/2 屏、1/4 屏、1/3 屏等多种分屏布局。 允许通过拖拽调整窗口大小。 安装： 访问扩展页面，点击 \u0026ldquo;Install\u0026rdquo; 按钮。 安装完成后，可以在 GNOME Tweaks 中启用。 Pop Shell\n功能： 类似平铺式窗口管理器的体验（Tiling Window Manager）。 提供键盘快捷键操作窗口的分屏布局。 支持鼠标拖拽、窗口栅格化等功能。 安装： 同样通过 GNOME Extensions 网站安装。 适合人群： 喜欢使用键盘快捷键的人。 需要动态调整窗口分屏的人。 WinTile\n功能： 提供类似 Windows 的分屏功能。 支持窗口左右、上下、四分屏。 适合人群： 更喜欢 Windows 分屏操作逻辑的人。 Dash to Panel\n功能： 并非直接用于分屏，但可以增强任务栏功能，方便窗口管理。 搭配： 可以与其他分屏扩展配合使用。 直接搜索安装即可\n","date":"2025年1月21日","permalink":"/posts/linux-preference/","section":"开发随笔","summary":"Useful system configuration for linux.","title":"linux preference"},{"content":" 我是一名机器人方向的开发者，专注于探索机器人技术的无限可能！ 日常写代码、调试硬件。\n我是谁？ #🌊 代码海里浪打浪，💻 bug修到心发慌。\n🤖 机器人前耍花样，🎮 游戏建模两手忙！\n✨ 键盘敲出星辰光，📚 学习笔记当干粮。\n🚢 翻船就当洗个澡，🥤 咖啡续命下一行。\n博客宣言 #📝 开发填坑写日志，\n📚 笔记拆解硬知识。\n💡 灵感突发乱来试，\n🎨 技术文艺两不迟。\n希望这里的内容能给您带来帮助，也期待与志同道合的朋友交流！🙌\n有任何问题或想法，随时留言或通过我的GitHub找到我，一起让技术更有趣！🚀\n","date":null,"permalink":"/","section":"Profile","summary":"","title":"Profile"},{"content":"Congo has full support for Hugo taxonomies and will adapt to any taxonomy set up. Taxonomy listings like this one also support custom content to be displayed above the list of terms.\nThis area could be used to add some extra descriptive text to each taxonomy. Check out the advanced tag below to see how to take this concept even further.\n","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" 记录技术探索中的灵感与经验。 💡 欢迎来到我的技术博客！这个板块致力于分享较为零碎的工作记录与开发心得。 无论是解决技术难题，还是记录日常的开发灵感，每一篇文章都是博主技术成长旅程中的一份脚印。 希望能为您提供启发，也期待您的反馈与交流！\n","date":null,"permalink":"/posts/","section":"开发随笔","summary":"","title":"开发随笔"},{"content":"","date":null,"permalink":"/tags/can/","section":"Tags","summary":"","title":"Can"},{"content":"","date":null,"permalink":"/tags/embedded/","section":"Tags","summary":"","title":"Embedded"},{"content":"This is a note for learning embedded linux development. The used development board is N32G0 of Nationstech\nReference Links # Nationstech Developer Community 野火 tutorial for embedded linux development Environment Config # Nationstech Tutorial VsCode #Clangd # To understand your source code, clangd needs to know your build flags. (This is just a fact of life in C++, source files are not self-contained).\nBy default, clangd will assume your code is built as clang some_file.cc, and you’ll probably get spurious errors about missing #included files, etc.\nFor this project , we use bear tool to generate compile_commands.json.\n确保 Bear 已安装\nsudo apt-get install bear\n导航到项目根目录 确保您在项目的根目录下：\ncd ~/SumResearch_2024/Repository/Nations.N32G030_Library.1.1.0\n使用 Bear 生成 compile_commands.json 文件\nbear -- make -C projects/n32g030_EVAL/gripper/GCC clean bear -- make -C projects/n32g030_EVAL/gripper/GCC\nGCC # Arm GNU Toolchain Downloads – Arm Developer Choose the right version： unpack the file： tar -xf arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-eabi.tar.xz 这将会在当前目录下解压出一个名为 arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-eabi 的文件夹。\n选择安装位置： 将解压后的工具链移动到适当的位置，比如 /opt 目录下 sudo mv arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-eabi /opt 设置环境变量： echo \u0026#39;export PATH=\u0026#34;/opt/arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-eabi/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 验证安装： Create a C file and run command below to confirm the installation of GCC. arm-none-eabi-gcc -o output_file source_file.c Expect output:\n.NET6 # Download .NET 6.0 (Linux, macOS, and Windows) When firstly opened a project with extension EIDE, it would warn that:\nNot found .NET6 runtime on your pc, please install it !\nDirectly click the official link and follow the guide then we can download the correct version.\nJlink # J-Link Software and Documentation Pack We can directly download the .deb pack or others.\nAfter download, use command below to vertify\nJLinkExe --version expect output:\nSEGGER J-Link Commander V7.96s (Compiled Jul 4 2024 18:19:44) DLL version V7.96s, compiled Jul 4 2024 18:19:18 Connect To Board #Connecting to target via SWD Found SW-DP with ID 0x0BB11477 DPv0 detected CoreSight SoC-400 or earlier Scanning AP map to find all available APs AP[1]: Stopped AP scan as end of AP map has been reached AP[0]: AHB-AP (IDR: 0x04770021) Iterating through AP map to find AHB-AP to use AP[0]: Core found AP[0]: AHB-AP ROM base: 0xE00FF000 CPUID register: 0x410CC200. Implementer code: 0x41 (ARM) Found Cortex-M0 r0p0, Little endian. FPUnit: 4 code (BP) slots and 0 literal slots CoreSight components: ROMTbl[0] @ E00FF000 [0][0]: E000E000 CID B105E00D PID 000BB008 SCS [0][1]: E0001000 CID B105E00D PID 000BB00A DWT [0][2]: E0002000 CID B105E00D PID 000BB00B FPB Memory zones: Zone: \u0026#34;Default\u0026#34; Description: Default access mode Cortex-M0 identified. sudo JLinkGDBServer -device N32G030C8 -if SWD -speed 4000 Connecting to J-Link... J-Link is connected. Firmware: J-Link ARM-OB STM32 compiled Aug 22 2012 19:52:04 Hardware: V7.00 S/N: 20090928 Feature(s): RDI,FlashDL,FlashBP,JFlash,GDB Checking target voltage... Target voltage: 3.30 V Listening on TCP/IP port 2331 Connecting to target... Halting core... Connected to target Waiting for GDB connection... Then we can use DEBUG in VsCode. It may meet report an error:\nThat means the lack of libncursesw.\nsudo apt-get update sudo apt-get install libncursesw5 sudo apt-get install libncurses5 Armcc #Armcc is included in DS-5, however, Arm DS-5 has been superseded by Arm Development Studio. Evaluation licenses are only available for the latest version of Arm DS.\nLinux下armcc和arm-linux交叉编译环境的配置_Linux编程_Linux公社-Linux系统门户网站\nArm Development Studio\nTo start using Arm Development Studio 2024.0 either: - Create a suite sub-shell using /opt/arm/developmentstudio-2024.0/bin/suite_exec \u0026lt;shell\u0026gt; - Launch GUI tools via their desktop menu entries The Release notes for the product can be found here: file:///opt/arm/developmentstudio-2024.0/sw/info/readme.html VOFA+ #Download the software directly from on official website.\nVOFA+ After installation, double-clicking the software icon does not start the program normally. Run it in terminal, it would repot the error:\nvofa+: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory\nBefore UBUNTU22.04, we may can install it directly\nsudo apt install libssl1.1 After 22.04, we can\u0026rsquo;t find the package because libssl1.1 may have been replaced by libssl3.\nLuckily, I found libssl1.1 in my system:\nfind / -name \u0026#34;libcrypto.so*\u0026#34; # OUTPUT: /opt/QQ/resources/app/avsdk/libcrypto.so.1.1 So we can make symbolic link:\nsudo ln -s /opt/QQ/resources/app/avsdk/libcrypto.so.1.1 /usr/lib/libcrypto.so.1.1 If we can\u0026rsquo;t find libssl1.1, we can download QQ-linux or download it manually (for reference only).\n下载 OpenSSL 1.1 源码\nwget https://www.openssl.org/source/openssl-1.1.1k.tar.gz tar -zxvf openssl-1.1.1k.tar.gz cd openssl-1.1.1k\n配置和安装\n使用自定义前缀安装到特定路径以避免与系统版本冲突：\n./config --prefix=/usr/local/openssl-1.1 --openssldir=/usr/local/openssl-1.1 make sudo make install\n配置动态链接库路径\n将新安装的 OpenSSL 库路径添加到系统库路径中：\necho \u0026quot;/usr/local/openssl-1.1/lib\u0026quot; | sudo tee /etc/ld.so.conf.d/openssl-1.1.conf sudo ldconfig\n确认安装是否成功 # 验证 OpenSSL 版本\n通过指定路径运行新安装的 OpenSSL 来确认版本：\n/usr/local/openssl-1.1/bin/openssl version\n检查库文件\n确认新库文件存在于指定路径：\nls /usr/local/openssl-1.1/lib\nttyUSB #ttyUSB cannot be used directly In Ubuntu22.04.\nCheck the state of the USB device\nsudo dmesg | grep tty # output [ 0.068371] printk: console [tty0] enabled [ 555.498168] usb 3-3.3: ch341-uart converter now attached to ttyUSB0 [ 556.189007] usb 3-3.3: usbfs: interface 0 claimed by ch341 while \u0026#39;brltty\u0026#39; sets config #1 [ 556.189756] ch341-uart ttyUSB0: ch341-uart converter now disconnected from ttyUSB0 It indicates that brltty has taken control of the CH341 device.\nWe can uninstall it directly:\nsudo apt-get remove --purge brltty Then reboot Ubuntu and check the USB again:\n[ 0.066547] printk: console [tty0] enabled [ 4.535503] usb 3-3.3: ch341-uart converter now attached to ttyUSB03 # OR: ls /dev/ttyUSB* Environment Configuration Test #GCC #With the help of VsCode extension EIDE, it\u0026rsquo;s convient to use gcc to compile chips of Cortex-M4 series. However, it doesn\u0026rsquo;t support Cortex-M0 series.\nN32 G4x #[ INFO ] start outputting files ... \u0026gt;\u0026gt; output hex file [done] file path: \u0026#34;build/N32G45x_GCC/N32G45xDemo.hex\u0026#34; \u0026gt;\u0026gt; output bin file [done] file path: \u0026#34;build/N32G45x_GCC/N32G45xDemo.bin\u0026#34; [ DONE ] build successfully !, elapsed time 0:0:0 N32 G0x #Armcc #compile # ","date":"2025年1月14日","permalink":"/posts/embedded-linux-development/","section":"开发随笔","summary":"A note for learning embedded linux development. The used development board is N32G0 of \u003cem\u003eNationstech\u003c/em\u003e","title":"Embedded Development on Linux"},{"content":" 一、安装必要的软件包 #Python-can #sudo apt-get update sudo apt-get install python3 python3-pip pip3 install python-can 成功安装python-can库后，可能出现关于脚本路径的警告，提示我们添加环境变量。 在.bashrc添加语句并source\nexport PATH=$PATH:/home/semitia/.local/bin can-utils工具 #sudo apt-get install can-utils 二、测试CAN转USB设备 #1. 检查USB设备 #使用lsusb命令查看系统是否识别到你的USB设备：\nlsusb 2. 检查网络接口 #使用ip link命令查看系统中是否存在CAN网络接口：\nip link 查找类似can0的接口。如果存在，则表示系统已经识别到你的CAN设备并创建了相应的网络接口。\n3. 使用dmesg查看系统日志 #可以使用dmesg命令查看系统日志，了解设备连接时的详细信息：\ndmesg | grep can 4. 配置和启动CAN接口 #如果已经检测到设备，可以使用以下命令配置和启动CAN接口（假设设备名为can0）：\nsudo ip link set can0 up type can bitrate 1000000 6. 收发测试 #使用candump命令监听CAN总线上的消息：\ncandump can0 若CAN设备和连接正常，则能够看到总线上传输的消息。 如果有两个设备，可以使用cansend命令通过另一个设备发送消息：\ncansend can1 123#12345678 这将发送4个字节数据，ID为0x123，接收效果如下。\ncan0 123 [4] 12 34 56 78 7. 检查设备状态 #显示CAN接口的详细状态信息，包括配置和错误统计数据。\nip -details link show can0 三、使用Python-can库 #import can import time import threading # 设置CAN接口的配置 can0_config = { \u0026#39;interface\u0026#39;: \u0026#39;socketcan\u0026#39;, \u0026#39;channel\u0026#39;: \u0026#39;can0\u0026#39;, \u0026#39;bitrate\u0026#39;: 500000 } can1_config = { \u0026#39;interface\u0026#39;: \u0026#39;socketcan\u0026#39;, \u0026#39;channel\u0026#39;: \u0026#39;can1\u0026#39;, \u0026#39;bitrate\u0026#39;: 500000 } # 定义要发送的消息 messages = [ \u0026#34;Hello from CAN0!\u0026#34;, \u0026#34;Greetings from CAN1!\u0026#34;, \u0026#34;CAN is fun!\u0026#34;, \u0026#34;Let\u0026#39;s communicate!\u0026#34; ] def can_sender(bus, msg_id, message): data = [ord(c) for c in message] # 将字符串转换为字节数组 msg = can.Message(arbitration_id=msg_id, data=data[:8], is_extended_id=False) try: bus.send(msg) print(f\u0026#34;Message sent on {bus.channel_info}: ID={msg_id} Data={message}\u0026#34;) except can.CanError: print(\u0026#34;Message NOT sent\u0026#34;) def can_receiver(bus): while True: msg = bus.recv() if msg: received_message = \u0026#39;\u0026#39;.join(chr(byte) for byte in msg.data) print(f\u0026#34;Message received on {bus.channel_info}: {received_message}\u0026#34;) def main(): # 创建CAN总线对象 can0 = can.Bus(**can0_config) can1 = can.Bus(**can1_config) # 启动接收线程 receiver_thread_0 = threading.Thread(target=can_receiver, args=(can0,)) receiver_thread_1 = threading.Thread(target=can_receiver, args=(can1,)) receiver_thread_0.start() receiver_thread_1.start() # 发送消息 for message in messages: can_sender(can0, 0x100, message) time.sleep(1) # 休息一段时间以避免发送冲突 can_sender(can1, 0x200, message) time.sleep(1) # 允许一些时间来接收消息 time.sleep(5) # 关闭CAN总线 can0.shutdown() can1.shutdown() return if __name__ == \u0026#34;__main__\u0026#34;: main() 四、关闭设备 # sudo ip link set can0 down sudo ip link set can1 down links #Updater - CANable\n扒一个超棒的stm32的开源usb-can项目，canable及PCAN固件-CSDN博客\nrbei-etas/busmaster: BUSMASTER is an Open Source Software tool to simulate, analyze and test data bus systems such as CAN. BUSMASTER was conceptualized, designed and implemented by Robert Bosch Engineering and Business Solutions (RBEI). Presently it is a joint project of RBEI and ETAS GmbH. (github.com)\ncangaroo - GitCode\nMakerbase CANable V2.0在Window系统使用_canable 2.0-CSDN博客\nCANable updater #linux #sudo nano /etc/udev/rules.d/48-stm-dfu.rules # 添加 SUBSYSTEMS==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;0483\u0026#34;, ATTR{idProduct}==\u0026#34;df11\u0026#34;, MODE:=\u0026#34;0666\u0026#34; sudo udevadm control --reload-rules sudo udevadm trigger ","date":"2025年1月14日","permalink":"/posts/usb2can-on-ubuntu/","section":"开发随笔","summary":"Simple usage of usb2can on Ubuntu","title":"usb2can on Ubuntu"},{"content":"This is the advanced tag. Just like other listing pages in Congo, you can add custom content to individual taxonomy terms and it will be displayed at the top of the term listing. 🚀\nYou can also use these content pages to define Hugo metadata like titles and descriptions that will be used for SEO and other purposes.\n","date":null,"permalink":"/tags/advanced/","section":"Tags","summary":"","title":"advanced"},{"content":"这是高级标签。就像Congo中的其他列表页面一样，您可以为单个分类术语添加自定义内容，并将其显示在术语列表的顶部。 🚀\n您还可以使用这些内容页面定义Hugo元数据，如标题和描述，这将用于SEO和其他目的。\n","date":"0001年1月1日","permalink":"/tags/advanced/_index.zh-cn/","section":"Tags","summary":"","title":"advanced"},{"content":" 探索机器人技术的无限可能，分享项目与研究成果。 🚀 欢迎来到我的 Projects 页面！在这里，我将展示自己在机器人领域的一些项目。\n","date":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":"Congo完全支持Hugo分类法，并将适应任何分类法设置。像这样的分类法列表还支持在术语列表上方显示自定义内容。\n这个区域可以用来添加一些额外的描述性文本到每个分类法。查看下面的 高级标签 了解如何进一步学习这个概念。\n","date":"0001年1月1日","permalink":"/tags/_index.zh-cn/","section":"Tags","summary":"","title":"Tags"},{"content":" 记录技术探索中的灵感与经验。 💡 欢迎来到我的技术博客！这个博客致力于分享与机器人技术相关的工作记录与开发心得。 无论是解决技术难题，还是记录日常的开发灵感，每一篇文章都是博主技术成长旅程中的一份脚印。 希望能为您提供启发，也期待您的反馈与交流！\n","date":null,"permalink":"/notes/","section":"开发随笔","summary":"","title":"开发随笔"}]